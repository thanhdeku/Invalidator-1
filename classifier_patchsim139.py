from lib import utils_ps as ut
from tqdm import tqdm
import os
from lib.utils_ps import read_idx2id


def print_info(patch):
    try:
        project, bug_id, correctness, tool = ut.read_info_patch(patch)
    except:
        project, bug_id, correctness, tool = ut.read_info_patch(patch)
    print("------- Patch {} info -------".format(patch))
    print(
        "Patch: {}\nProject: {}\nBug id: {}\nGenerated by: {}\nCorrectness: {}"
        .format(patch, project, bug_id, tool, correctness))
    print("---------------------------------\n")
    return project, bug_id, correctness, tool

def get_error_behaviour_syntax(bugprog, devprog):
    print("Error behaviours ...")
    error_beha = {}
    keys = list(bugprog.keys())
    for i in tqdm(range(len(keys))):
        program_point = keys[i]
        if program_point in devprog:
            bug_inv = bugprog[program_point]
            dev_inv = devprog[program_point]
            error_beha[program_point] = []
            for inv_b in bug_inv:
                if inv_b not in dev_inv:
                    error_beha[program_point].append(inv_b)

def get_patch_difference(baselineprog, prog):
    print("Error behaviours ...")
    diff = {}
    keys = list(prog.keys())
    for i in tqdm(range(len(keys))):
        program_point = keys[i]
        if program_point in baselineprog:
            prog_inv = prog[program_point]
            baseline_inv = baselineprog[program_point]
            diff[program_point] = []
            for inv in prog_inv:
                if inv not in baseline_inv:
                    diff[program_point].append(inv)
        else:
            diff[program_point] = []
            for inv in prog[program_point]:
                diff[program_point].append(inv)
    return diff

def get_patch_intersect(baselineprog, prog):
    print("Correct specifications ...")
    intersection = {}
    keys = list(baselineprog.keys())
    for i in tqdm(range(len(keys))):
        program_point = keys[i]
        if program_point in prog:
            baseline_inv = baselineprog[program_point]
            patch_inv = prog[program_point]
            intersection[program_point] = []
            for inv_b in baseline_inv:
                if inv_b in patch_inv:
                    intersection[program_point].append(inv_b)
    return intersection

def overfitting_1_syntax(patch_inv, error_beha, cf):
    score = 0
    for program_point in patch_inv:
        if program_point in error_beha:
            for inv in error_beha[program_point]:
               if inv in patch_inv[program_point]:
                   print(program_point + ": \t")
                   print(inv)
                   if inv != "Exiting Daikon.":
                       score += cf[program_point][inv]
    
    return score

def overfitting_2_syntax(patch_inv, correct_spec, cf):
    score = 0
    for program_point in patch_inv:
        if program_point in correct_spec:
            for inv in correct_spec[program_point]:
               if inv not in patch_inv[program_point]:
                   if inv != "Exiting Daikon.":
                       score += cf[program_point][inv]

    return score  

def a_divide_b(a,b):
    if b != 0:
        return a/b
    else:
        return 0

def classifier(cf_threshold, softrules = True, hardrules = True, learning = True, only_learning = False):
    total = 0
    overfit = 0
    true_overfit = 0
    false_overfit = 0
    total_correct = 0
    total_incorrect = 0
    list_patches = os.listdir("ICSE22_data/data/raw_invariants/patchsim_139/patches")
    count = 0
    idx2id = read_idx2id()
    learning_prob= ut.read_learning_distance()
    list_correct = []
    list_incorrect = []
    miss_correctness = []
    rs4project_tp = {"Chart": 0, "Time": 0, "Lang": 0, "Math": 0}
    rs4project_fp = {"Chart": 0, "Time": 0, "Lang": 0, "Math": 0}
    total_correct_perproject = {"Chart": 0, "Time": 0, "Lang": 0, "Math": 0}
    total_incorrect_perproject = {"Chart": 0, "Time": 0, "Lang": 0, "Math": 0}
    for patch in list_patches:
        print(patch)
        if patch == ".DS_Store" or patch == "incorrect":
            continue
        origin_patch = idx2id[int(patch)]
       
        project, bug_id, correctness, tool = ut.read_info_patch(origin_patch)
        
        # if project == "Closure":
        #     continue
        patch_invs_P, patch_invs_F, bug_invs_P, bug_invs_F, dev_invs_P, dev_invs_F = ut.read_invariant(
            project, bug_id, patch)
        cf_patch_P, cf_patch_F, cf_bug_P, cf_bug_F, cf_dev_P, cf_dev_F = ut.read_invariant_with_cf(
            project, bug_id, patch)
        rs = False

        correct_spec = get_patch_intersect(bug_invs_P, dev_invs_P)
        error_beha = get_patch_difference(dev_invs_F, bug_invs_F)
        
        count_violate = 0
        count_violate = overfitting_2_syntax(patch_invs_P, correct_spec, cf_dev_P)

        count_errors = 0
        count_errors = overfitting_1_syntax(patch_invs_F, error_beha, cf_bug_F)

        if hardrules:
            if count_violate > 0 or count_errors > 0:
                rs = True
        


        patch_diff_bug = get_patch_difference(bug_invs_F, patch_invs_F)
        patch_diff_dev = get_patch_difference(dev_invs_P, patch_invs_P)
        bug_diff_patch = get_patch_difference(patch_invs_F, bug_invs_F)
        dev_diff_patch = get_patch_difference(patch_invs_P, dev_invs_P)

        diff_bug_patch_score = 0
        diff_dev_patch_score = 0
        diff_patch_bug_score = 0
        diff_patch_dev_score = 0
        count_inv_patch_F = 0
        count_inv_patch_P = 0
        count_inv_bug_F = 0
        count_inv_dev_P = 0

        for key in cf_bug_F:
            for inv in cf_bug_F[key]:
                count_inv_bug_F += 1
        for key in cf_dev_P:
            for inv in cf_dev_P[key]:
                count_inv_dev_P += 1
        for key in cf_patch_F:
            for inv in cf_patch_F[key]:
                count_inv_patch_F += 1
        for key in cf_patch_P:
            for inv in cf_patch_P[key]:
                count_inv_patch_P += 1
        

        for key in patch_diff_bug:
            for inv in patch_diff_bug[key]:
                if inv != "Exiting Daikon.":
                    diff_patch_bug_score += cf_patch_F[key][inv]

        for key in patch_diff_dev:
            for inv in patch_diff_dev[key]:
                if inv != "Exiting Daikon.":
                    diff_patch_dev_score += cf_patch_P[key][inv]

        for key in bug_diff_patch:
            for inv in bug_diff_patch[key]:
                if inv != "Exiting Daikon.":
                    diff_bug_patch_score += cf_bug_F[key][inv]

        for key in dev_diff_patch:
            for inv in dev_diff_patch[key]:
                if inv != "Exiting Daikon.":
                    diff_dev_patch_score += cf_dev_P[key][inv]

        distance2incorrect = (a_divide_b(diff_patch_bug_score, count_inv_patch_F) + a_divide_b(diff_bug_patch_score, count_inv_bug_F))/2
        distance2correct = (a_divide_b(diff_patch_dev_score, count_inv_patch_P) + a_divide_b(diff_dev_patch_score, count_inv_dev_P))/2
        confidence_invariant = distance2correct - distance2incorrect
        confidence_learning = learning_prob[origin_patch][1] - learning_prob[origin_patch][0]
        
        # if confidence_invariant > 0 + confidence_learning > 0:
        if softrules:
            if learning:
                if (confidence_invariant + confidence_learning)/2 > cf_threshold:
                    rs = True
            else:
                if confidence_invariant > cf_threshold:
                    rs = True

        if only_learning:
            rs = False
            if learning_prob[origin_patch][1] > cf_threshold:
                    rs = True

        if rs is not None:
            if correctness == "Incorrect":
                total_incorrect += 1
                total_incorrect_perproject[project] += 1
            elif correctness == "Correct" or correctness == "Same":
                total_correct += 1
                total_correct_perproject[project] += 1
            else:
                miss_correctness.append(correctness)
            if rs:
                print("Patch: ", origin_patch, " Correctness: ", correctness)
                if correctness == "Incorrect":
                    rs4project_tp[project] += 1
                    list_incorrect.append(origin_patch)
                    true_overfit += 1
                elif correctness == "Correct" or correctness == "Same":
                    rs4project_fp[project] += 1
                    list_correct.append(origin_patch)
                    false_overfit += 1
  
    # print(count)
    return true_overfit, false_overfit, list_correct, rs4project_tp, rs4project_fp, total_incorrect_perproject, total_correct_perproject

if __name__ == "__main__":
    print(classifier(0, softrules = False, hardrules = True, learning = True, only_learning = False))
